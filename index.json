[{"content":"\r","date":"1 ינואר 0001","permalink":"/images/","section":"","summary":"\r","title":""},{"content":"","date":"1 ינואר 0001","permalink":"/posts/","section":"","summary":"","title":""},{"content":"","date":"1 ינואר 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/bloom/","section":"Tags","summary":"","title":"Bloom"},{"content":"מימשתי אפקט Bloom כמו ב Unity במנוע רינדור שאני מפתח.\nאפקט Bloom הוא אפקט טבעי שנראה כאשר יש עצם בוהק מאוד ונוצרת הילה סביבו (למשל השמש) . אפשר לראות Bloom בתמונות כאשר יש חשיפת יתר ומקור אור שכשהוא פוגע במלצמה הוא \u0026ldquo;שורף\u0026rdquo; את התמונה.\nבמשחקי מחשב האפקט נעשה בדרך כלל ב - Post processing, כלומר אחרי שעיבדנו את הסצנה מוסיפים לה האפקט. האפקט קיים במשחקי מחשב מתחילת שנות ה 2000 בערך, ולמרות שלאפקט יש פוטנציאל גדול להפוך כל סנצה למרהיבה וראליסטית אם ממשים אותו בצורה שלומיאלית או משתמשים בו בהגזמה הוא יכול להפוך גם את הסצנה היפה ביותר לאסון לעניים. (\rBloom Disasters - The Quixotic Engineer)\nאת המימוש של האפקט עשיתי בדומה לצורה שבה הוא ממומש ב Unity Engine ובעוד הרבה מקומות. את המקור למימוש ניתן למצוא במצגת מאת היוצרים של המשחק Call of Duty Advanced Warfare בה הם מספרים איך מימשו את אפקטי ה Post processing במשחק, ובין היתר Bloom.\nהמימוש נעשה ב 3 שלבים תהליך Downsampling בו דוגמים את התמונה ומורידים את הרזולוציה שלה כמה פעמים. תהליך Upsampling בו דוגמים את התמונה שעשינו לה Downsampling ומעלים את הרזולוציה שלה לרזולוציה המקורית. שילוב של התמונה המקורית והתמונה שקיבלנו בתהליך הקודם.\nתהליך ה Downsampling וה Upsampling\rבפירוט התהליך הוא כזה - לוקחים את התמונה המקורית, מורידים את הרזולוציה שלה בחצי וחוזרים על התהליך מספר פעמים, כאשר בכל פעם שאנחנו מורידים את הרזולוציה אנחנו דוגמים את התמונה ומטשטשים אותה מעצם הורדת הרזולוציה.\nהמימוש המדויק נעשה עם משקולות בהן ניתן משקל יותר גדול לפיקסלים שקרובים לפיקסל אותו אנו דוגמים במעבר מהרזולוציה המקורית לרזולוציה הנמוכה ממנה, כאשר המטרה היא לדגום מפיקסלים שליד פיקסל מסוים בשביל להעריך מה יהיה הצבע שלו.\nלאחר שסיימנו לבצע את תהליך הורדת האיכות של התמונה מספר פעמים נבצע Upsampling בשביל להחזיר אותה לרזולוציה המקורית, אך לא נקפוץ ישר לתמונה המקורית אלא נעלה בהדרגה את כמות הפיקסלים כמספר הפעמים שבהן הורדנו את הפיקסלים, עד לקבלת התמונה ברזולוציה המקורית.\nגם בתהליך ה Upsampling אנחנו נדגום את הפיקסלים ונעריך מה יהיה צבע הפיקסל שעליו אנחנו עובדים.\nאם לפשט בתהליך אנחנו מאבדים פיקסלים ומעריכים איך התמונה היתה נראה ברזולוציה נמוכה יותר, ולכן אנחנו מקבלים טשטוש מסוים (כי זה קירוב), ובכיוון ההפוך הדבר זהה, אנחנו מעריכים איך התמונה היתה נראת אם היו לה יותר פיקסלים כאשר את המעבר ליותר פקסלים אנחנו מבצעים מהתמונה המטושטשת.\nבסיום התהליך נקבל תמונה מטושטשת ואותה נשלב עם התמונה המקורית כאשר יהיה משקל גדול באופן ניכר לתמונה המקורית במיזוג בניהן.\nבמימוש שלי הוספתי שלב נוסף שקודם לשלבים שתיארתי ובו אני מחשב איזורים בתמונה שעוברים סף מסוים על מנת להקנות רק לאזורים שבאמת בוהקים בתמונה את האפקט.\nהסצנה הסופית בה ניתן לראות שיש אזורים בתמונה שיותר בהוקים מאחרים כאשר הם מוארים על ידי מקור אור.\rהסצנה לאחר הפעלת threshold\nבתמונה העליונה הסצנה לאחר הפעלת threshold כך שרק האזורים שאינם בשחור יעברו עיבוד. בתמונה התחתונה הסצנה לאחר 4 הפעלות של האלגוריתם ל Downsampling\rמשמאל לימין, בלי bloom, עם, עם כאשר ה bias בשילוב עם התמונה המקורית יותר גדול\rהתוצאה מוצגת בסרטון, אפשר לראות בו קסדה שמחזירה אור ובאזורים מסוימים היא בוהקת יותר כאשר קרן אור פוגעת בה ומקבלים הילה או זוהר. הסביבה מתחלפת ובכל אחת מהסביבות יש תאורה היקיפית קצת שונה.\nבחלק הבא בסרטון נטען מודל שנקרא Sponza (זה מדול של ארמון אמיתי שנמצא בקרואטיה Sponza Palace - Wikipedia). ואפשר לראות בצד ימין אינדיקטורים לחלקים בוהקים בסצנה ולתמונה במצבי טשטוש שונים (רזולציות שונות). בהמשך אני משחק עם ההגדרות ומציג עוד דוגמאות של האפקט.\nמוזיקה בסרטון:\nStream Paradox by JNATHYN | Listen online for free on SoundCloud\nאת המצגת של Call of duty אפשר למצוא פה:\nJorge Jimenez – Next Generation Post Processing in Call of Duty: Advanced Warfare\n","date":"1 ינואר 0001","permalink":"/posts/bloom/","section":"","summary":"מימשתי אפקט Bloom כמו ב Unity במנוע רינדור שאני מפתח.\nאפקט Bloom הוא אפקט טבעי שנראה כאשר יש עצם בוהק מאוד ונוצרת הילה סביבו (למשל השמש) . אפשר לראות Bloom בתמונות כאשר יש חשיפת יתר ומקור אור שכשהוא פוגע במלצמה הוא \u0026ldquo;שורף\u0026rdquo; את התמונה.","title":"Bloom"},{"content":"","date":"1 ינואר 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/ecs-system/","section":"Tags","summary":"","title":"Ecs system"},{"content":"לפני חודש העלתי פוסט על מנוע רינדור שפיתחתי ב C++ עם OpenGL לינק לפוסט הקודם- shorturl.at/cyA57\nהמשכתי לפתח את המנוע והוספתי לו\n-מנוע פיזיקלי -ממשק (משופר) -אפשרות להוסיף עצמים לסצנה באופן דינמי. -אפשרות לשנות את הטרנספורמציה(מיקום, גודל, ורוטציה) של עצמים בסצנה באופן דינמי. -מערכת ECS -תאורה מקומית ו Multiple lights -צללים\nכל הפיצ\u0026rsquo;רים האלה מעניינים ויכולים לקבל פוסט שמוקדש רק להם. אבל בפוסט הנוכחי אדבר בעיקר על ECS שזה - Entity Component System\nמערכת לניהול ישויות זאת מערכת שדרכה אפשר ליצור ישויות שמורכבות מרכיבים בודדים.\nבמילים הכי פשוטות ובאופן הכי מעשי נניח ויש לנו משחק מחשב, במקום שניצור מחלקה לדמות שנמצאת במשחק והיא תהווה יצוג של הדמות, לא ניצור מחלקה, אלא ניקח כל רכיב ששייך לדמות ונוסיף אותו לישות. באופן הזה הישות מורכבת מהחלקים הקטנים שלה, ואינה מוגדרת באופן סופי ואפשר להוסיף או להוריד לה רכיבים.\nהמערכת מאפשרת למשתמש ליצור ישויות, להרוס ישויות, לשמור אותן, לקבל את כל הישויות בעלות מאפיין מסוים, למשל כל הישויות שאפשר לצייר על המסך.\nהבעיה שמערכת כזאת באה לפתור היא הורשה מרובה, נניח ויש לנו משחק בו יש דמות וקיימת לנו בקוד מחלקה של דמות המתארת הרבה פרטים עליה, בתוך המחלקה יש שדות רלוונטים כמו מודל תלת ממדי של הדמות, מהירות, משקל, וכל פרמטר שנרצה שתכיל מחלקה כזאת.\nעד כאן הכל תקין, כעת נניח שנרצה ליצור דמות עם פרמטר שלא קיים במחלקת המקורית, ונרצה לשמור את מחלקת הדמות המקורית (ולא לשנות אותה) וגם להוסיף למחלקה מאפיינים חדשים, נשתמש בהורשה ונוריש ממחלקת הדמות המקורית את השדות והפונקציות למחלקת הדמות החדשה, או שאולי אפילו ניצור מחלקת אב שממנה כל דמות עם פרמטרים שונים תירש.\nהפתרון תאורטית נכון(הוא עובד) אבל הוא לא scalable, במצב בו יש לנו 2 דמויות עם פרמטרים שונים נצטרך לתחזק 2 מחלקות שונות, אבל מה יקרה אם יש לנו 20 דמויות שונות? זה אותו קוד בכל אותן מחלקות (ולכן השתמשנו בהורשה בשביל לא לחזור על קוד משותף) אבל לכל אחת יש מאפיינים טיפה שונים, אם נחשוב על המאפיינים האלה הם כקומפוננטות - רכיבים, זה היה יכול להיות יותר נחמד אם במקום לרשת, היינו מרכיבים ישות מכל אותם רכיבים ששונים בין המחלקות.\nזה בעצם מה שמערכת כזאת עושה, היא נותנת לנו לקבץ רכיבים ולהתייחס אליהם כאל ישות, לפי הרכיבים השונים שיש ליישות נדע איך להתייחס אליה (אין לנו קלאס, או מופע לישות, אנחנו לא יודעים מה זאת הישות הזאת אבל אנחנו יודעים איזה רכיבים היא מכילה ונתייחס אליה בהתאם).\nמערכת כזאת בעצם מממשת לנו Design pattern של קומפוזציה, צירפתי למי שמעוניין סרטון בו מראים דוגמאות קוד קונקרטיות איך מעבר לקומפוזיציה הופך את הקוד ליותר קריא, נוח לתחזוקה ועבודה.\nמה ניתן לראות בסרטון:\nבהתחלה אפשר לראות שאני מזיז את הקובייה האדומה בעזרת ה widgets שמופיעים לידה ברגע שהיא מסומנת, בסצנה הזאת רואים גם את הצללים שזזים עם הקובייה, כשאני לוחץ על פליי הסצנה מתחילה לרוץ והמנוע הפיזיקלי פועל ולכן העצמים נופלים לקרקע.\nמסביב לעצמים עם ערכים פיזיקלים כמו הרצפה והקוביות מופיעים קווים ירוקים ברגע שלוחצים פליי, הם נועדו למטרת דיבאג.\nבהמשך אפשר לראות שאני משחק עם תאורה מקומית ומשנה את הצבעים והמיקום שלה. כמה פריימים אחרי אפשר לראות מה קורה כשמפילים גוש של קוביות ואיך האינטראקציה בניהן נראת ושכמה מהן נופלות מהמשטח.\n","date":"1 ינואר 0001","permalink":"/posts/ecs/","section":"","summary":"לפני חודש העלתי פוסט על מנוע רינדור שפיתחתי ב C++ עם OpenGL לינק לפוסט הקודם- shorturl.at/cyA57\nהמשכתי לפתח את המנוע והוספתי לו\n-מנוע פיזיקלי -ממשק (משופר) -אפשרות להוסיף עצמים לסצנה באופן דינמי.","title":"ECS system"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/engine/","section":"Tags","summary":"","title":"Engine"},{"content":"","date":"1 ינואר 0001","permalink":"/series/engine/","section":"Series","summary":"","title":"Engine"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/features/","section":"Tags","summary":"","title":"features"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/pbr/","section":"Tags","summary":"","title":"PBR"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/rendering/","section":"Tags","summary":"","title":"Rendering"},{"content":"","date":"1 ינואר 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"מנוע רינדור בזמן אמת שנכתב למטרת למידה, נכתב ב C++ עם OpenGL מכיל פיצ\u0026rsquo;רים כמו מנוע פיזיקלי, טעינת מודלים, תאורה דינמית, רינדור בטכניקת PBR, תמיכה באנימציות, ממשק ועוד.\nPrevious\rNext\r","date":"1 ינואר 0001","permalink":"/","section":"SkyEngine home","summary":"מנוע רינדור בזמן אמת שנכתב למטרת למידה, נכתב ב C++ עם OpenGL מכיל פיצ\u0026rsquo;רים כמו מנוע פיזיקלי, טעינת מודלים, תאורה דינמית, רינדור בטכניקת PBR, תמיכה באנימציות, ממשק ועוד.\nPrevious\rNext\r","title":"SkyEngine home"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"אכתוב בהמשך\n","date":"1 ינואר 0001","permalink":"/about/","section":"SkyEngine home","summary":"אכתוב בהמשך","title":"עליי"},{"content":"הצגת פרויקט\nפיתחתי מנוע רינדור בזמן אמת ב C++ עם OpenGL.\nאז מה זה בעצם מנוע רינדור?\rמנוע רינדור מהווה אבסטרקציה בשביל לצייר על המסך עצמים. הוא עושה שימוש בכרטיס הגרפי של המחשב - GPU בשביל להמיר לוגיקה (למשל מודל תלת ממדי) לתמונה דו ממדית שאפשר להציג על מסך.\nקצת על המוטיבציה שלי לפתח מנוע רינדור, תמיד אהבתי גרפיקה, במשחקי מחשב מה שמשך אותי למשחק מסוים הוא בדרך כלל הגרפיקה, ובתור ילד עניין אותי איך תראה הגרפיקה של העתיד וכמה מציאותית היא תראה, מעבר לאהבה האישית שלי לגרפיקה זה תחום מאתגר.\nמצאתי הרבה אתגרים מעניינים בתחום הפיתוח הגרפי בגלל התעסקות המתמטית (אלגברה לינארית) וגם מבחינה תכנותית יש צורך לכתוב קוד יעיל ואופטימלי ולכן גם לרוב מפתחים מנועים בשפות מהירות \u0026ldquo;ונמוכות\u0026rdquo; כמו C++.\nמעבר למנוע או לסט יכולות הבסיסי שהוא תומך בהן, פיתחתי באמצעותו סצנה/משחקון, סוג של מבוך בעולם תלת מימדי עם עצמים שדרכם אי אפשר לעבור.\nועל אותו עולם הפעלתי אלגוריתם A* (אי סטאר) למציאת הנתיב הקצר ביותר בין שתי נקודות.\nהאלגוריתם הוא הרחבה של האלגוריתם של דייקסטרה, ובעל שימוש נרחב במשחקי מחשב למשל מציאת נתיב בין דמות השחקן ליעד.\nהמימוש של האלגוריתם היה מאתגר במקצת למרות שהאלגוריתם לא מסובך.\nהאלגוריתם מבצע חיפוש על גרף, ולכן יש צורך בצמתים ולי אין צמתים, יש לי עולם תלת מימדי עם אין סוף נקודות.\nלכן הייתי צריך להמיר את העולם לצמתים.\nהגדרתי ריבועים על מפה וכל נקודה בה שייכת לריבוע מסוים.\nאבל מה עושים אם קיים אובייקט חוסם על חלק מהצומת(ריבוע) אבל לא על כולו? הוא עדיין חוסם? אם כן, בזבזנו מקום שיכולנו ללכת דרכו וכתוצאה האלגוריתמים יהיה פחות מדויק.\nאם נקטין כל ריבוע ונגדיל את מספר הריבועים כך שחוסר הדיוק יקטן האלגוריתם ירוץ פחות מהר, ככל שהמפה גדלה או שנרצה להגדיל את הדיוק מספר הריבועים יעשה אסטרונומי.\nלדוגמה התקבעתי על גודל ריבוע שצלעותיו הן 1.\nועל רשת שגודלה 64 * 64 - 4096 ריבועים.\nאם נחליט להקטין את גודל הריבועים בחצי בשביל להוסיף דיוק נהפוך את גודל הרשת ל 128 * 128.\nבמקום 4096 ריבועים נקבל 16 אלף ריבועים. שיקול כזה גם משפיע על האופן שבו כדאי לממש ולשקול באיזה מבני נתונים להשתמש.\nOpenGL היא מכונת מצבים, וככזאת קשה לדבג אותה או להבין מה קורה בתוכה ובאיזה מצב היא נמצאת.\nיש לה output בסיסי אם הקלט שהיא קיבלה לא טוב, אבל מעבר ליכולת בסיסית לדבג בעיות בסיסיות קשה לרוב להבין למה דברים לא מופיעים על המסך כמו שמצופה.\nלכן החלטתי לממש כלים לדיבוג ויזואלי למשל רשת שתציג לי כל ריבוע על המפה, סימון עצמים ואיזה ריבוע הם תופסים, סימון הנתיבים של האלגוריתים וכדומה.\nהיו לי לבטים האם להשקיע את הזמן בשביל לפתח אינדיקציות ויזואליות.\nבדיעבד אני יכול להגיד שזה חסך זמן, יש ערך \u0026ldquo;לראות בעיניים\u0026rdquo; מה קורה על המסך מאשר לקוות שהערכים שצריכים להיות אכן ישנם 🌝.\nמה ניתן לראות בסרטון המצורף מלבד כישורי עריכה ממוצעים:\nתאורה דינאמית, רקעים וטקסטורות שונות, טעינת מודלים והדגמה של סצנה שאפשר ליצור למשל עם הספה, המחשב וכל המסביב. בסוף הסרטון ניתן לראות פינגווין שמטרתו להגיע לספסל (כנראה שהתעייף) במסלול הקצר ביותר.\nהאלגוריתם A* מוצג באופן ויזואלי כאשר הצמתים המסומנים באדום הם צמתים שנסגרו\nוהירוקים הם הדרך הקצרה ביותר, האלגוריתם פועל באופן מיידי והאנימציה הואטה בכוונה בשביל שיהיה ניתן לראות מה קורה.\n","date":"1 ינואר 0001","permalink":"/posts/start/","section":"","summary":"הצגת פרויקט\nפיתחתי מנוע רינדור בזמן אמת ב C++ עם OpenGL.\nאז מה זה בעצם מנוע רינדור?\rמנוע רינדור מהווה אבסטרקציה בשביל לצייר על המסך עצמים. הוא עושה שימוש בכרטיס הגרפי של המחשב - GPU בשביל להמיר לוגיקה (למשל מודל תלת ממדי) לתמונה דו ממדית שאפשר להציג על מסך.","title":"פוסט ראשון"},{"content":"\rFeatures\u003e\rFeatures # Core\nShaders. Physics Engine. Entities system. Light, uniforms. Model loading \u0026amp; Mesh System. Animations. 3D Model Loading supports all major types such as FBX, glTF, obj, collada and more. Framebuffers \u0026amp; Textures System. Rendering\nPBR lighting model. Environment maps Runetime IBL. Normal mapping. Blinn-Phong lighting Model. Multiple Lights. Post-processing\nHDR Tone Mapping Gamma correction. Simple \u0026amp; Customizable UI.\nמנוע פיזיקלי\u003e\rמנוע פיזיקלי # אנימציות\u003e\rאנימציות # ניתן להלביש אנימציות על מודלים. מערכת טקסטורות\u003e\rמערכת טקסטורות # המערכת מאפשר לטעון טקסטורות באופן א-סנכרוני(מקבילי), למודלים תלת ממדיים, או ל Mesh ספציפי של מודל תלת ממדי. אפשר לטעון טקסטורות בודדות על ידי גרירה שלהן או ב Bulk.\nתאורה סביבתית (IBL)\u003e\rתאורה סביבתית (IBL) # IBL - Image Based Lighting תאורה סביבתית היא תאורה שנוצרת מהסביבה ובעצם תורמת לראליזם של הסצנה. אפשר לראות בסרטון שיש לנו משטח אבל לא קיימת תאורה כלל, ולאחר שטוענים סביבה נוצר אור ממנה. ריבוי אורות\u003e\rריבוי אורות # המנוע תומך ביותר ממקור אור אחד, וניתן להוסיף ולהסיר אורות לסנצה בהתאם לצורך ממשק פשוט ויכולת התאמה\u003e\rממשק פשוט ויכולת התאמה # ניתן לשנות, ולשחק עם הממשק כך שיתאים למשתמש. ","date":"1 ינואר 0001","permalink":"/features/","section":"SkyEngine home","summary":"Features\u003e\rFeatures # Core\nShaders. Physics Engine. Entities system. Light, uniforms. Model loading \u0026amp; Mesh System. Animations. 3D Model Loading supports all major types such as FBX, glTF, obj, collada and more.","title":"פיצ'רים"},{"content":"בהמשך לפוסטים הקודמים על המנוע רינדור שאני מפתח:\nStart - 1\nEcs - 2\nהוספתי את הפיצ\u0026rsquo;רים הבאים\nרינדור PBR תמיכה באנימציות של מודלים תאורה מבוססת תמונה (IBL) מערכת טקסטורות ניתן לקרוא על חלק מהפיצ\u0026rsquo;רים האלה בקצרה כאן פיצ\u0026rsquo;רים\nבפסוט זה אתמקד ב PBR .\nדוגמאות לרינדור ב PBR PBR - physically based rendering\rהיא טכניקת רינדור שמדמה בצורה יותר טובה את המציאות והתנהגות עצמים בעולם האמיתי, המטרה של הטכניקה היא להשיג Photorealism והיא עושה את זה על ידי עקרונות פיזיקלים, למשל שימור אנרגיה - אובייקט יחזיר כמות אור שווה או פחותה לכמות האור שפגעה בו(ולא יחזיר יותר אור), במודלים יותר פשוטים אין התייחסות כזאת וכתוצאה מכך התמונות יכולות להיראות פחות ראליסטיות.\nהטכניקה מבוססת על עקרונות פיזיקלים כמו\nשימור אנרגיה. כל אובייקט נמצא בסקאלה שבין חומר מוליך למבודד, למשל מתכת היא חומר מוליך וכתוצאה מכך תחזיר אור בצורה שונה מאשר פלסטיק. לכל אובייקט יש ערך עבור רמת החספוס שלו לעמות כמה הוא חלק. באמצעות התייחסות לכל הפרמטרים האלה אפשר ליצור תמונה יותר ראלית ואיכותית.\nחשוב לציין שקיימות טכניקות כדוגמת Ray tracing ואחרות שיכולות להגיע לביצועים יותר טובים מבחינת איכות וראליזם של סצנה, אבל טכניקות אלה אינן מיועדות ל real time rendering (אם כי ככל שמשתפרים המעבדים הגרפיים טכניקות אלה נהיות יותר ישימות).\nיישום הטכניקה\u003e\rיישום הטכניקה # היישום של הטכניקה הזאת כולל הרבה מתמטיקה מורכבת, ומשוואה לא מי יודע מה סימפטית שכוללת אינטגרל ונקראת The Rendering Equation (מקורי), אחסוך את כתיבת המשוואה אבל אתאר שהמשוואה כוללת פונקציית פיזור שבהינתן ערכים כמו רמת החספוס של אובייקט אפשר להעריך איך יתנהג אור שיפגע באובייקט.\nחלק אחר במשוואה מעריך את כמות האור שחוזר בהתאם לזווית שהאור פוגע באובייקט ומיקום הצופה, למשל משטח פרקט יחזיר אור כאשר הוא נצפה בזווית גדולה, אבל אם נצפה בו בזווית של 90 מעלות כמות \u0026ldquo;ההברקה שלו\u0026rdquo; (האור שחוזר) תהיה יותר קטנה.\nקיימים עוד חלקים במשוואה שאחסוך את תיאורם.\nטקסטורות\u003e\rטקסטורות # ההיתרון של הטכניקה הזאת מבחינת המשתמש הוא לא רק בכך שהיא מספקת תמונה ראליסטית אלא שהיא גם מאפשרת לשחק עם הערכים של אובייקט מסוים בצורה נוחה יותר מאשר טכניקות ישנות ועל ידה אפשר להגיע לתוצאה רצויה מבחינת מראה האובייקט בצורה פשוטה יותר.\nאת הערכים שהזכרתי קודם(מתכתיות, רמת חספוס ועוד) של אובייקט מייצגים באמצעות טקסטורה, טקסטורה היא תמונה רגילה, דו-ממדית שעוטפים את האובייקט באמצעותה.\nעושים את זה על ידי מיפוי של הטקסטורה לאובייקט, אם נדמיין למשל קובייה עם 6 פאות ונביט בפאה מסוימת אז לאותה פאה יש אזור בטקסטורה שהוא ממפוה אליה, ניקח את הצבע (או ערך אחר)שמופיע בקטסטורה ונציג אותו במקום הרצוי באובייקט בהתאם למיפוי.\nבטכניקת PBR מראה של אובייקט מורכב לרוב מ - 5 טקסטורות בסיסיות\nColor/Albedo Normal Metallic Roughness Ambient occlusion הטקסטורות מופיעות בסדר שציינתי משמאל לימין\nהרעיון הכללי הוא שנקודד מידע בצורה מוסכמת מראש על גבי הטקסטורה והמידע הזה ישמש אותנו להציג את האובייקט.\nנסתכל למשל על הטקסטורה השלישית, היא הטקסטורה שקובעת את ערך המתכתיות של האובייקט, הסיבה שהצבעים שלה מאוד שונים מהטקסטורות Albedo/Normal היא שערך המתכתיות הוא ערך שנע בין 0 ל 1, כאשר 1 הוא לבן ו 0 שחור בתמונה. באובייקט שיש לנו בתמונה(כדור המתכת) הוא או מאוד מתכתי בנקודות שאין בהן חלודה, או שהוא כמעט ולא בנקודות החלודות, לכן הערכים התואמים נצבעים בערכים שקרובים ל 0 או 1.\nבטקסטורה הזאת(המתכתית) בדרך כלל אין טעם לשמור ערכים בכל ערוצי הצבע הקיימים בתמונה\nRGB - RED ,GREEN, BLUE\rלכן הערך נשמר רק בערוץ הראשון, RED ואילו בשאר הטקסטורות יש טעם לקודד יותר מידע, ושאר הערוצים בתמונה נמצאים בשימוש מה שנותן לטקסטורות מראה אחר.\nהטקסטורות הראשונה Albedo היא טקסטורה שמיועדת להציג את הצבעים של האובייקט ולכן יש הרבה דימיון בינה לבין איך שהאובייקט נראה, היא משתמשת בכל 3 הערוצים של התמונה.\nהטקסטורה הבאה ה Normal זוהי טקסטורה שנועדה לתת תחושה שלאובייקט יש יותר עומק ממה שיש לו, התמונה הבאה ממחישה את ההבדל שעושה הטקסטורה הזאת אפשר לשים לב שבצד שמאל יש לנו משטח חלק ואחיד מה שחוסך לנו כוח עיבוד בהצגתו, ועדיין באמצעות שימוש בטקסטורה נוכל לתת תחושה שהמשטח עמוק ובעל פני שטח לא אחידים כמו בצד ימין.\nהטקסטורה מייצגת ווקטורים עבור כל נקודה בתמונה, באמצעות הווקטורים האלה נדע איך האור יתפזר על האובייקט, ואיפה העומק שלו. כנראה שמתם לב שהטקסטורה בצבע סגלגל והיא שונה מכל שאר הטקסטורות, הסיבה שהיא בצבע כזה היא הצורה שבה אנו ממפים את המידע. אנחנו משתמשים בכל הערוצים של התמונה RGB וממפים אותם לקורדינאטות של וקטור XYZ, מכיוון שכיוון הווקטור על פני המשטח תמיד ילך קדימה ולא לאחור שכן הווקטור מיועד לצופה, ערך ה Z יהיה חיובי ובדרך כלל 1, מה שיתן לתמונה צבע כחול כפי שמומחש בתמונה הטקסטורה של הכדור המתכתי חלקה מכיוון שהכדור חלק, בתמונה הבאה אפשר לראות את הדפוס שטקסטורה אחרת יוצרת עבור אובייקט אחר.\nהטקסטורות Albedo/Normal משתמשות בכל ערוצי התמונה על מנת לקודד את המידע בעוד שאר הטקסטורות משתמשות רק בערוץ אחד. אם נרצה לחסוך במספר הטקסטורות שנטען למנוע ובכך לחסוך זיכרון וזמן עיבוד נוכל לאחד את כל 3 הטקסטורות לטקסטורה אחת שנקראת ARM -Ambient Roughness Metallic והיא תראה כך\nסיכום\u003e\rסיכום # PBR היא טכניקה מורכבת שנותנת תחושה הרבה יותר ראליסטית לעומת טכניקות אחרות, היא מאפשרת למעצב הגרפי שמעצב את האובייקטים בסצנה חופש יותר גדול בעיצוב וכן אפשרות לקסטם את המאפיינים של האובייקט בצורה נוחה. בטכניקות אחרות כדוגמת Blinn-Phong הראליזם פחות מאשר PBR וגם קיימים פחות פרמטרים אשר קובעים את המראה דבר המקשה על מעצבים להגיע לתוצאה רצויה.\nבתמונות הבאות אפשר לראות את התוצאה במנוע\nבסרטון ניתן לראות שינוי של ערכי המתכתיות והחספוס של האובייקט על ידי המנוע, אפשר להתרשם מכך ששינוי הערכים מקנה תחושה של אובייקטים מסוגים שונים.\r","date":"1 ינואר 0001","permalink":"/posts/pbr/","section":"","summary":"בהמשך לפוסטים הקודמים על המנוע רינדור שאני מפתח:\nStart - 1\nEcs - 2\nהוספתי את הפיצ\u0026rsquo;רים הבאים\nרינדור PBR תמיכה באנימציות של מודלים תאורה מבוססת תמונה (IBL) מערכת טקסטורות ניתן לקרוא על חלק מהפיצ\u0026rsquo;רים האלה בקצרה כאן פיצ\u0026rsquo;רים","title":"רינדור מבוסס פיזיקה"}]