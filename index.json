[{"content":"\r","date":"1 ינואר 0001","permalink":"/images/","section":"","summary":"\r","title":""},{"content":"","date":"1 ינואר 0001","permalink":"/posts/","section":"","summary":"","title":""},{"content":"","date":"1 ינואר 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 ינואר 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/ecs/","section":"Tags","summary":"","title":"ecs"},{"content":"לפני חודש העלתי פוסט על מנוע רינדור שפיתחתי ב C++ עם OpenGL לינק לפוסט הקודם- shorturl.at/cyA57\nהמשכתי לפתח את המנוע והוספתי לו\n-מנוע פיזיקלי -ממשק (משופר) -אפשרות להוסיף עצמים לסצנה באופן דינמי. -אפשרות לשנות את הטרנספורמציה(מיקום, גודל, ורוטציה) של עצמים בסצנה באופן דינמי. -מערכת ECS -תאורה מקומית ו Multiple lights -צללים\nכל הפיצ\u0026rsquo;רים האלה מעניינים ויכולים לקבל פוסט שמוקדש רק להם. אבל בפוסט הנוכחי אדבר בעיקר על ECS שזה - Entity Component System\nמערכת לניהול ישויות זאת מערכת שדרכה אפשר ליצור ישויות שמורכבות מרכיבים בודדים.\nבמילים הכי פשוטות ובאופן הכי מעשי נניח ויש לנו משחק מחשב, במקום שניצור מחלקה לדמות שנמצאת במשחק והיא תהווה יצוג של הדמות, לא ניצור מחלקה, אלא ניקח כל רכיב ששייך לדמות ונוסיף אותו לישות. באופן הזה הישות מורכבת מהחלקים הקטנים שלה, ואינה מוגדרת באופן סופי ואפשר להוסיף או להוריד לה רכיבים.\nהמערכת מאפשרת למשתמש ליצור ישויות, להרוס ישויות, לשמור אותן, לקבל את כל הישויות בעלות מאפיין מסוים, למשל כל הישויות שאפשר לצייר על המסך.\nהבעיה שמערכת כזאת באה לפתור היא הורשה מרובה, נניח ויש לנו משחק בו יש דמות וקיימת לנו בקוד מחלקה של דמות המתארת הרבה פרטים עליה, בתוך המחלקה יש שדות רלוונטים כמו מודל תלת ממדי של הדמות, מהירות, משקל, וכל פרמטר שנרצה שתכיל מחלקה כזאת.\nעד כאן הכל תקין, כעת נניח שנרצה ליצור דמות עם פרמטר שלא קיים במחלקת המקורית, ונרצה לשמור את מחלקת הדמות המקורית (ולא לשנות אותה) וגם להוסיף למחלקה מאפיינים חדשים, נשתמש בהורשה ונוריש ממחלקת הדמות המקורית את השדות והפונקציות למחלקת הדמות החדשה, או שאולי אפילו ניצור מחלקת אב שממנה כל דמות עם פרמטרים שונים תירש.\nהפתרון תאורטית נכון(הוא עובד) אבל הוא לא scalable, במצב בו יש לנו 2 דמויות עם פרמטרים שונים נצטרך לתחזק 2 מחלקות שונות, אבל מה יקרה אם יש לנו 20 דמויות שונות? זה אותו קוד בכל אותן מחלקות (ולכן השתמשנו בהורשה בשביל לא לחזור על קוד משותף) אבל לכל אחת יש מאפיינים טיפה שונים, אם נחשוב על המאפיינים האלה הם כקומפוננטות - רכיבים, זה היה יכול להיות יותר נחמד אם במקום לרשת, היינו מרכיבים ישות מכל אותם רכיבים ששונים בין המחלקות.\nזה בעצם מה שמערכת כזאת עושה, היא נותנת לנו לקבץ רכיבים ולהתייחס אליהם כאל ישות, לפי הרכיבים השונים שיש ליישות נדע איך להתייחס אליה (אין לנו קלאס, או מופע לישות, אנחנו לא יודעים מה זאת הישות הזאת אבל אנחנו יודעים איזה רכיבים היא מכילה ונתייחס אליה בהתאם).\nמערכת כזאת בעצם מממשת לנו Design pattern של קומפוזציה, צירפתי למי שמעוניין סרטון בו מראים דוגמאות קוד קונקרטיות איך מעבר לקומפוזיציה הופך את הקוד ליותר קריא, נוח לתחזוקה ועבודה.\nמה ניתן לראות בסרטון:\nבהתחלה אפשר לראות שאני מזיז את הקובייה האדומה בעזרת ה widgets שמופיעים לידה ברגע שהיא מסומנת, בסצנה הזאת רואים גם את הצללים שזזים עם הקובייה, כשאני לוחץ על פליי הסצנה מתחילה לרוץ והמנוע הפיזיקלי פועל ולכן העצמים נופלים לקרקע.\nמסביב לעצמים עם ערכים פיזיקלים כמו הרצפה והקוביות מופיעים קווים ירוקים ברגע שלוחצים פליי, הם נועדו למטרת דיבאג.\nבהמשך אפשר לראות שאני משחק עם תאורה מקומית ומשנה את הצבעים והמיקום שלה. כמה פריימים אחרי אפשר לראות מה קורה כשמפילים גוש של קוביות ואיך האינטראקציה בניהן נראת ושכמה מהן נופלות מהמשטח.\n","date":"1 ינואר 0001","permalink":"/posts/ecs/","section":"","summary":"לפני חודש העלתי פוסט על מנוע רינדור שפיתחתי ב C++ עם OpenGL לינק לפוסט הקודם- shorturl.at/cyA57\nהמשכתי לפתח את המנוע והוספתי לו\n-מנוע פיזיקלי -ממשק (משופר) -אפשרות להוסיף עצמים לסצנה באופן דינמי.","title":"ECS system"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/features/","section":"Tags","summary":"","title":"features"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/posts/","section":"Tags","summary":"","title":"posts"},{"content":"","date":"1 ינואר 0001","permalink":"/series/posts/","section":"Series","summary":"","title":"posts"},{"content":"","date":"1 ינואר 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"מנוע רינדור בזמן אמת שנכתב למטרת למידה, נכתב ב C++ עם OpenGL מכיל פיצ\u0026rsquo;רים כמו מנוע פיזיקלי, טעינת מודלים, תאורה דינמית, רינדור בטכניקת PBR, תמיכה באנימציות, ממשק ועוד.\nPrevious\rNext\r","date":"1 ינואר 0001","permalink":"/","section":"SkyEngine home","summary":"מנוע רינדור בזמן אמת שנכתב למטרת למידה, נכתב ב C++ עם OpenGL מכיל פיצ\u0026rsquo;רים כמו מנוע פיזיקלי, טעינת מודלים, תאורה דינמית, רינדור בטכניקת PBR, תמיכה באנימציות, ממשק ועוד.\nPrevious\rNext\r","title":"SkyEngine home"},{"content":"","date":"1 ינואר 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"אכתוב בהמשך\n","date":"1 ינואר 0001","permalink":"/about/","section":"SkyEngine home","summary":"אכתוב בהמשך","title":"עליי"},{"content":"הצגת פרויקט\nפיתחתי מנוע רינדור בזמן אמת ב C++ עם OpenGL.\nאז מה זה בעצם מנוע רינדור?\rמנוע רינדור מהווה אבסטרקציה בשביל לצייר על המסך עצמים. הוא עושה שימוש בכרטיס הגרפי של המחשב - GPU בשביל להמיר לוגיקה (למשל מודל תלת ממדי) לתמונה דו ממדית שאפשר להציג על מסך.\nקצת על המוטיבציה שלי לפתח מנוע רינדור, תמיד אהבתי גרפיקה, במשחקי מחשב מה שמשך אותי למשחק מסוים הוא בדרך כלל הגרפיקה, ובתור ילד עניין אותי איך תראה הגרפיקה של העתיד וכמה מציאותית היא תראה, מעבר לאהבה האישית שלי לגרפיקה זה תחום מאתגר.\nמצאתי הרבה אתגרים מעניינים בתחום הפיתוח הגרפי בגלל התעסקות המתמטית (אלגברה לינארית) וגם מבחינה תכנותית יש צורך לכתוב קוד יעיל ואופטימלי ולכן גם לרוב מפתחים מנועים בשפות מהירות \u0026ldquo;ונמוכות\u0026rdquo; כמו C++.\nמעבר למנוע או לסט יכולות הבסיסי שהוא תומך בהן, פיתחתי באמצעותו סצנה/משחקון, סוג של מבוך בעולם תלת מימדי עם עצמים שדרכם אי אפשר לעבור.\nועל אותו עולם הפעלתי אלגוריתם A* (אי סטאר) למציאת הנתיב הקצר ביותר בין שתי נקודות.\nהאלגוריתם הוא הרחבה של האלגוריתם של דייקסטרה, ובעל שימוש נרחב במשחקי מחשב למשל מציאת נתיב בין דמות השחקן ליעד.\nהמימוש של האלגוריתם היה מאתגר במקצת למרות שהאלגוריתם לא מסובך.\nהאלגוריתם מבצע חיפוש על גרף, ולכן יש צורך בצמתים ולי אין צמתים, יש לי עולם תלת מימדי עם אין סוף נקודות.\nלכן הייתי צריך להמיר את העולם לצמתים.\nהגדרתי ריבועים על מפה וכל נקודה בה שייכת לריבוע מסוים.\nאבל מה עושים אם קיים אובייקט חוסם על חלק מהצומת(ריבוע) אבל לא על כולו? הוא עדיין חוסם? אם כן, בזבזנו מקום שיכולנו ללכת דרכו וכתוצאה האלגוריתמים יהיה פחות מדויק.\nאם נקטין כל ריבוע ונגדיל את מספר הריבועים כך שחוסר הדיוק יקטן האלגוריתם ירוץ פחות מהר, ככל שהמפה גדלה או שנרצה להגדיל את הדיוק מספר הריבועים יעשה אסטרונומי.\nלדוגמה התקבעתי על גודל ריבוע שצלעותיו הן 1.\nועל רשת שגודלה 64 * 64 - 4096 ריבועים.\nאם נחליט להקטין את גודל הריבועים בחצי בשביל להוסיף דיוק נהפוך את גודל הרשת ל 128 * 128.\nבמקום 4096 ריבועים נקבל 16 אלף ריבועים. שיקול כזה גם משפיע על האופן שבו כדאי לממש ולשקול באיזה מבני נתונים להשתמש.\nOpenGL היא מכונת מצבים, וככזאת קשה לדבג אותה או להבין מה קורה בתוכה ובאיזה מצב היא נמצאת.\nיש לה output בסיסי אם הקלט שהיא קיבלה לא טוב, אבל מעבר ליכולת בסיסית לדבג בעיות בסיסיות קשה לרוב להבין למה דברים לא מופיעים על המסך כמו שמצופה.\nלכן החלטתי לממש כלים לדיבוג ויזואלי למשל רשת שתציג לי כל ריבוע על המפה, סימון עצמים ואיזה ריבוע הם תופסים, סימון הנתיבים של האלגוריתים וכדומה.\nהיו לי לבטים האם להשקיע את הזמן בשביל לפתח אינדיקציות ויזואליות.\nבדיעבד אני יכול להגיד שזה חסך זמן, יש ערך \u0026ldquo;לראות בעיניים\u0026rdquo; מה קורה על המסך מאשר לקוות שהערכים שצריכים להיות אכן ישנם 🌝.\nמה ניתן לראות בסרטון המצורף מלבד כישורי עריכה ממוצעים:\nתאורה דינאמית, רקעים וטקסטורות שונות, טעינת מודלים והדגמה של סצנה שאפשר ליצור למשל עם הספה, המחשב וכל המסביב. בסוף הסרטון ניתן לראות פינגווין שמטרתו להגיע לספסל (כנראה שהתעייף) במסלול הקצר ביותר.\nהאלגוריתם A* מוצג באופן ויזואלי כאשר הצמתים המסומנים באדום הם צמתים שנסגרו\nוהירוקים הם הדרך הקצרה ביותר, האלגוריתם פועל באופן מיידי והאנימציה הואטה בכוונה בשביל שיהיה ניתן לראות מה קורה.\n","date":"1 ינואר 0001","permalink":"/posts/start/","section":"","summary":"הצגת פרויקט\nפיתחתי מנוע רינדור בזמן אמת ב C++ עם OpenGL.\nאז מה זה בעצם מנוע רינדור?\rמנוע רינדור מהווה אבסטרקציה בשביל לצייר על המסך עצמים. הוא עושה שימוש בכרטיס הגרפי של המחשב - GPU בשביל להמיר לוגיקה (למשל מודל תלת ממדי) לתמונה דו ממדית שאפשר להציג על מסך.","title":"פוסט ראשון"},{"content":"\rFeatures\u003e\rFeatures # Core\nShaders. Physics Engine. Entities system. Light. , uniforms. Model loading \u0026amp; Mesh System. Animations. 3D Model Loading supports all major types such as FBX, glTF, obj, collada and more. Framebuffers \u0026amp; Textures System. Rendering\nPBR lighting model. Environment maps Runetime IBL. Normal mapping. Blinn-Phong lighting Model. Multiple Lights. Post-processing\nHDR Tone Mapping Gamma correction. Simple \u0026amp; Customizable UI.\nמנוע פיזיקלי\u003e\rמנוע פיזיקלי # אנימציות\u003e\rאנימציות # ניתן להלביש אנימציות על מודלים. מערכת טקסטורות\u003e\rמערכת טקסטורות # המערכת מאפשר לטעון טקסטורות באופן א-סנכרוני(מקבילי), למודלים תלת ממדיים, או ל Mesh ספציפי של מודל תלת ממדי. אפשר לטעון טקסטורות בודדות על ידי גרירה שלהן או ב Bulk.\nתאורה סביבתית (IBL)\u003e\rתאורה סביבתית (IBL) # IBL - Image Based Lighting תאורה סביבתית היא תאורה שנוצרת מהסביבה ובעצם תורמת לראליזם של הסצנה. אפשר לראות בסרטון שיש לנו משטח אבל לא קיימת תאורה כלל, ולאחר שטוענים סביבה נוצר אור ממנה. ריבוי אורות\u003e\rריבוי אורות # המנוע תומך ביותר ממקור אור אחד, וניתן להוסיף ולהסיר אורות לסנצה בהתאם לצורך ממשק פשוט ויכולת התאמה\u003e\rממשק פשוט ויכולת התאמה # ניתן לשנות, ולשחק עם הממשק כך שיתאים למשתמש. ","date":"1 ינואר 0001","permalink":"/features/","section":"SkyEngine home","summary":"Features\u003e\rFeatures # Core\nShaders. Physics Engine. Entities system. Light. , uniforms. Model loading \u0026amp; Mesh System. Animations. 3D Model Loading supports all major types such as FBX, glTF, obj, collada and more.","title":"פיצ'רים"}]